# Even More Pointers, Arrays & Strings

[0. memset](./0-memset.c) - In this task, we are to create a function that fills the first `n` bytes of the memory area pointed to by `s` with the constant byte `b`. The function makes use of the `memset()` function in C Library that fills a certain bytes of the memory area pointed to by the pointer passed as an argument with a certain constant.

[1. memcpy](./1-memcpy.c) - Creating a function that copies `n` bytes from memory area `src` to memory area `dest`. The function uses the `memcpy()` function in C Library that copies a specified number of bytes from a memory area pointed to by a pointer and copies to a memory area pointed by anothe pointer. This function returns a pointer to memory area where the bytes have been copied to.

[2. strchr](./2-strchr.c) - Creating a function that locates a character i a string. The function returns a pinter to the first occurence of the character `c` in the string `s`, or `NULL` if the character is not found. We make use of the C Library function `strchr()` that searches for a character in a given string pointed by the pointer passed as argument. It is worth noting that the pointer returned points to the first occurence of the character and if used to deference will return the part of the string starting from the first occurence of the character.

[3. strspn](./3-strspn.c) - Creating a function that gets the length of a prefix substring. The function returns the number of bytes in the initial segment of `s` which consisit only of bytes from `accept`. This function makes use of the `strspn()` function in C Library which returns the number of characters in the initial segment of str1, passed as the first argument, which consist only of characters from str2, passed as the second argument.

[4. strpbrk](./4-strpbrk.c) - Creating a function that searches a string for any of a set of bytes. The function locates the first occurence in the string `s` of any of the bytes in the string `accept`. It then returns a pointer to the byte in `s` that matches one of the bytes in `accept`, or `NULL` if no such byte is found. To achieve this, we will make use of the `strpbrk()` function in the C Library. If we dereference the pointer returned by this function, then we expect to have the part of the string starting from where a certain character that was in the `accept` first occured, to the last character of the string `s`.

[5. strstr](./5-strstr.c) - Creating a function that locates a substring. The function finds the first occurrence of the substring `needle` in the string `haystack`, the terminating null bytes (`\0`) are not compared. The function returns a pointer to the begining of the located substring, or `NULL` if the substring is not found. The task makes use of the `strstr()` function in the C Library.

[6. Chess is mental torture](./7-print_chessboard.c) - Creating a function to print the chessboard. This is a mimic of how a chessboard looks like. The idea is to be able to work with `2D Arrays`, since the values of the board are store in a 2D array. We can therefore loop through the array and print each value which is a character, using the _putchar() custom function.

[7. The line of life is a ragged diagonal between duty and desire](./8-print_diagsums.c) - Creating a function that prints the sum of the two diagonals of a square matrix of integers. Note that in the following example we are casting an int[][] into an int*. This is not something you should do. The goal here is to make sure you understand how an array of array is stored in memory. The matrix being described is just a `2D Array` with `size` being its dimensions. Since the array has been casted to an array of integers, `(int *)`, we can only use **pointer arithmetics** to access a random element `arr[i][j]`. To get the first sum of diagonals, basically the sum of values along the diagonal line of the matrix (2D Array), we can use `*(a + i * size + i)`. Here we are dereferencing the first the `arr[i][j]` pointed to by the pointer. `a` points to the first element of the matrix, `i` is the index of the row, `size` is the number of columns in the matrix, and the last `i` indicates the column we want to access within the current row. This will alwas access the value on the diagonal line. Similary, to get the values of the other diagonal, we can use `*(a + i * size + (size - 1 - i)` which will return the values on the diagonal. We can the sum up these values and print them.


[8. Double pointer, double fun](./100-set_string.c) - Creating a function that sets the value of a pointer to a char. From the prototype of the function, `void set_string(char **s, char *to);`, we can see that the first parameter is a double pointer, it stores the address of another pointer. 
